###### 类被初始化的5个条件，被称为主动引用【初始化前肯定已经触发了类的加载--》连接（包含验证，准备，解析部分过程）】
1. 遇到字节码指令：new，getstatic，putstatic，invokestatic时，如果类没有被初始化，则需要出发类的初始化，生成该4条字节码指令的java代码，如使用new关键字创建实例，读取或者设置类的静态变量（不包含使用final修饰的基本类型的静态常量），调用类的静态方法时；
2. 使用java.lang.reflect包对类实现反射调用时，如果类没有被初始化，则初始化；
3. 当初始化子类时，如果其父类没有被初始化，则需要先初始化父类，再初始化子类；
4. 当虚拟机执行时，虚拟机需要一个执行入口（即包含main方法的类），则需要先初始化该类；
5. 当需要进行动态语言的支持时，即调用java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic，REF_putstatic，REF_invokestatic方法句柄，并且该方法句柄所对应的类没有被初始化时，则需要先触发类的初始化；

###### 类不被初始化的3个情况，被称为被动引用 
1. 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化；
2. 通过数组定义来引用类，不会触发此类的初始化；
3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化；